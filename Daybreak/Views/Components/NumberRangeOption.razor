<div class="option-display-box">
    <div class="option-content">
        <div class="option-title">@this.Name</div>
        <div class="option-description">
            @this.Description
            @if (this.MinValue.HasValue && this.MaxValue.HasValue)
            {
                <div class="option-range-info">
                    Range: @this.MinValue - @this.MaxValue
                </div>
            }
        </div>
    </div>
    <div class="option-control">
        <FluentNumberField @bind-Value="this.Value" 
                           @onchange="this.OnValueChanged"
                           style="width: 220px;" 
                           Min="@(this.MinValue?.ToString())"
                           Max="@(this.MaxValue?.ToString())"
                           Step="@(this.GetStep().ToString())"
                           Placeholder="Enter a number" />
    </div>
</div>

@inherits OptionBase<double>
@code {
    [Parameter]
    public required IValidator Validator { get; init; }

    private double? MinValue { get; set; }
    private double? MaxValue { get; set; }

    protected override double ConvertValue(OptionInstance optionInstance, OptionProperty property)
    {
        var numberValue = property.Getter(optionInstance);
        if (numberValue is null)
        {
            return 0.0;
        }

        var value = numberValue switch
        {
            double var => var,
            IConvertible convertible => convertible.ToDouble(null),
            _ => 0.0
        };

        return value;
    }

    protected override Task OnParametersSetAsync()
    {
        this.ExtractValidatorLimits();
        return base.OnParametersSetAsync();
    }

    private void ExtractValidatorLimits()
    {
        if (this.Validator is ClampedValidator clampedValidator)
        {
            if (clampedValidator.MinValue is IConvertible minConvertible)
            {
                this.MinValue = minConvertible.ToDouble(null);
            }

            if (clampedValidator.MaxValue is IConvertible maxConvertible)
            {
                this.MaxValue = maxConvertible.ToDouble(null);
            }
        }
    }

    private double GetStep()
    {
        // Determine appropriate step based on property type
        return this.Property.Type switch
        {
            Type t when t == typeof(int) || t == typeof(uint) || 
                       t == typeof(long) || t == typeof(ulong) ||
                       t == typeof(short) || t == typeof(ushort) => 1.0,
            Type t when t == typeof(float) || t == typeof(double) => 0.1,
            _ => 1.0
        };
    }

    private void OnValueChanged(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var newValue))
        {
            // Convert back to the original property type
            var convertedValue = this.Property.Type switch
            {
                Type t when t == typeof(int) => (object)(int)newValue,
                Type t when t == typeof(uint) => (object)(uint)newValue,
                Type t when t == typeof(long) => (object)(long)newValue,
                Type t when t == typeof(ulong) => (object)(ulong)newValue,
                Type t when t == typeof(short) => (object)(short)newValue,
                Type t when t == typeof(ushort) => (object)(ushort)newValue,
                Type t when t == typeof(float) => (object)(float)newValue,
                Type t when t == typeof(byte) => (object)(byte)newValue,
                _ => (object)newValue
            };

            if (this.Validator.IsValid(convertedValue))
            {
                this.Value = newValue;
                this.Property.Setter(this.Instance, convertedValue);
                this.NotifyValueChanged();
            }
        }
    }
}
