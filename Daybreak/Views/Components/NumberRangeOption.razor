<div class="option-display-box backdrop-panel display-box">
    <div class="option-content">
        <div class="option-title">@this.Name</div>
        <div class="option-description">
            @this.Description
            @if (this.MinValue.HasValue && this.MaxValue.HasValue)
            {
                <div class="option-range-info">
                    Range: @this.MinValue - @this.MaxValue
                </div>
            }
        </div>
    </div>
    <div class="option-control">
        <FluentNumberField @bind-Value="this.Value" 
                          @onchange="OnValueChanged"
                          style="width: 180px;" 
                          Min="@(this.MinValue?.ToString())"
                          Max="@(this.MaxValue?.ToString())"
                          Step="@(this.GetStep().ToString())"
                          Placeholder="Enter a number" />
    </div>
</div>

@inherits OptionBase<double>
@code {
    [Parameter]
    public required IValidator Validator { get; init; }

    private double? MinValue { get; set; }
    private double? MaxValue { get; set; }

    public override double ConvertValue(OptionInstance optionInstance, OptionProperty property)
    {
        var numberValue = property.Getter(optionInstance);
        if (numberValue is null)
        {
            return 0.0;
        }

        var value = numberValue switch
        {
            double var => var,
            IConvertible convertible => convertible.ToDouble(null),
            _ => 0.0
        };

        return value;
    }

    protected override Task OnParametersSetAsync()
    {
        ExtractValidatorLimits();
        return base.OnParametersSetAsync();
    }

    private void ExtractValidatorLimits()
    {
        if (this.Validator is not null)
        {
            var validatorType = this.Validator.GetType();
            
            // Check if it's a ClampedValidator
            if (validatorType.IsGenericType && 
                validatorType.GetGenericTypeDefinition().Name.Contains("ClampedValidator"))
            {
                try
                {
                    // Use reflection to get the private fields
                    var minField = validatorType.GetField("minValue", 
                        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                    var maxField = validatorType.GetField("maxValue", 
                        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

                    if (minField?.GetValue(this.Validator) is IConvertible minConvertible)
                    {
                        this.MinValue = minConvertible.ToDouble(null);
                    }

                    if (maxField?.GetValue(this.Validator) is IConvertible maxConvertible)
                    {
                        this.MaxValue = maxConvertible.ToDouble(null);
                    }
                }
                catch
                {
                    // Fallback if reflection fails
                    this.MinValue = null;
                    this.MaxValue = null;
                }
            }
        }
    }

    private double GetStep()
    {
        // Determine appropriate step based on property type
        return this.Property.Type switch
        {
            Type t when t == typeof(int) || t == typeof(uint) || 
                       t == typeof(long) || t == typeof(ulong) ||
                       t == typeof(short) || t == typeof(ushort) => 1.0,
            Type t when t == typeof(float) || t == typeof(double) => 0.1,
            _ => 1.0
        };
    }

    private void OnValueChanged(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var newValue))
        {
            // Clamp the value to the valid range
            if (this.MinValue.HasValue && newValue < this.MinValue.Value)
                newValue = this.MinValue.Value;
            if (this.MaxValue.HasValue && newValue > this.MaxValue.Value)
                newValue = this.MaxValue.Value;

            this.Value = newValue;
            
            // Convert back to the original property type
            var convertedValue = this.Property.Type switch
            {
                Type t when t == typeof(int) => (int)newValue,
                Type t when t == typeof(uint) => (uint)newValue,
                Type t when t == typeof(long) => (long)newValue,
                Type t when t == typeof(ulong) => (ulong)newValue,
                Type t when t == typeof(short) => (short)newValue,
                Type t when t == typeof(ushort) => (ushort)newValue,
                Type t when t == typeof(float) => (float)newValue,
                Type t when t == typeof(double) => newValue,
                _ => newValue
            };
            
            this.Property.Setter(this.Instance, convertedValue);
        }
    }
}
